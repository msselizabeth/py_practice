'''
Расчет Евклидова расстояния (Основа k-NN)

Цель: Научиться работать с "векторами" (списками) одинаковой длины и применять к ним попарные операции.

Связь с ML: Это буквально сердце алгоритмов, основанных на "близости", таких как k-Nearest Neighbors (k-NN) и кластеризация. Модель ищет "ближайших соседей" к новой точке данных, вычисляя именно это расстояние.

Задача:Данные в ML часто представляются как точки в N-мерном пространстве ("векторы").point_a = [1, 5, 2]point_b = [3, 1, 6]

Напишите функцию euclidean_distance(v1, v2), которая принимает два списка (вектора) одинаковой длины и вычисляет Евклидово расстояние между ними.
Формула: sqrt{(v1_1 - v2_1)^2 + (v1_2 - v2_2)^2 + ... + (v1_n - v2_n)^2}

Для point_a и point_b это будет:
sqrt of ((1 - 3)^2 + (5 - 1)^2 + (2 - 6)^2 )= 6.0

На что обратить внимание:
Как одновременно пройтись по двум спискам? (Подсказка: zip()).Как получить квадратный корень? (Подсказка: import math, затем math.sqrt()... или просто ** 0.5).
Эту задачу можно очень красиво решить в одну-две строки, используя zip() и list comprehension (или генераторное выражение) внутри функции sum().

Дополнительная сложность (moderate++):
Напишите вторую функцию find_nearest(query_point, dataset), которая принимает "целевую точку" (query_point) и "набор данных" (dataset — список таких же точек) и возвращает индекс самой близкой точки из dataset.
'''
import math 

point_a = [1, 5, 2] 
point_b = [3, 1, 6]

def euclidean_distance(v1, v2):
    
    points = list(zip(v1, v2))
    # print(points[0])
    # print(points[0][0])
    # print(points[0][1])
    sum = 0
    for p in points:
        print(p) #(1,3)
        sum += (p[0] - p[1]) ** 2
        # try:
        #     print(p[0])
        #     print(p[1])
        #     print(p[2])
        # except IndexError:
        #     pass
            # print("index out of range")
            # continue
        
    result = math.sqrt(sum)
    print(sum)
    print(result)
    print(points)
    return result
    
euclidean_distance(point_a, point_b)

